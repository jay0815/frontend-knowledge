# ES5 模拟 ES6+ 类的方法

在 ES5 环境中，由于没有原生的 `class` 语法，我们需要使用函数和原型机制来模拟 ES6+ 中的类。本文档总结了常用的方法、关键点以及相应的实现示例。

---

## 1. 基本原理

- **构造函数**：  
  使用函数作为构造函数，通过 `new` 关键字创建实例，并在构造函数中初始化实例属性。

- **原型**：  
  将类的方法定义在构造函数的原型上，使得所有实例共享同一份方法代码，从而节省内存并提高性能。

- **严格模式**：  
  启用 `"use strict"`，防止 `this` 绑定错误、意外创建全局变量以及捕获其他常见错误。

---

## 2. 防止错误调用

在 ES6 类中，如果直接调用构造函数或原型方法（而非使用 `new`），通常会报错。为了在 ES5 中模拟这一行为，我们可以：

- **构造函数调用检查**：  
  在构造函数内部使用 `if (!(this instanceof Constructor))` 判断是否通过 `new` 调用，若不是则抛出错误。

- **原型方法调用检测**：  
  封装原型方法，检测调用时是否错误地使用了 `new`。通常通过检测 `this instanceof method`（其中 `method` 是原始方法）来判断方法是否被当作构造函数调用。

---

## 3. 使用 Object.defineProperty 定义原型方法

为使原型方法与 ES6 类默认行为一致，需要注意以下几点：

- **不可枚举**：  
  类中的方法不应在 `for...in` 等循环中枚举出来，因此在使用 `Object.defineProperty` 定义方法时，将 `enumerable` 设置为 `false`。

- **可写 & 可配置**：  
  默认情况下，`Object.defineProperty` 定义的属性 `writable` 和 `configurable` 都为 `false`。为了允许后续修改和重新配置，需将它们设置为 `true`。

---

## 4. 包装原型方法

为了在调用原型方法前统一检测是否误用 `new` 调用，我们可以封装一个辅助函数（例如 `innerDefineOwnProperty`），将检测逻辑与原始方法包装起来。

[示例代码](./target.ts#L23-L56)

关于具名函数与匿名函数

- **具名函数举**：
  推荐使用具名函数，因为它们在调试时能提供更清晰的错误信息和堆栈追踪。
- **匿名函数**：
  虽然匿名函数也能工作，但在调试时可能难以确定问题所在。因此，为了便于维护和调试，建议使用具名函数。

## 5. 完整示例

[class代码](./class.ts)

[target代码](./target.ts)

## 6. 总结
- 使用 构造函数 和 原型 机制模拟 ES6+ 类。
- 通过 严格模式 防止 this 绑定错误及全局变量污染。
- 使用 Object.defineProperty 定义 非枚举、可写、可配置 的原型方法。
- 包装原型方法，检测是否误用 new 调用，从而保持类的正确行为。
- 推荐使用 具名函数 以便于调试，但匿名函数在技术上也是可行的。